- [JVM (Java Virtual Machine)](#jvm-java-virtual-machine)
  - [役割](#役割)
  - [ライフサイクル](#ライフサイクル)
  - [部品](#部品)
  - [対応言語](#対応言語)
  - [よくある操作・機能](#よくある操作機能)
  - [クラスローダー](#クラスローダー)
    - [機能、動作](#機能動作)
    - [クラスローダーの種類](#クラスローダーの種類)
  - [実行エンジン](#実行エンジン)
  - [Javaネイティブインターフェース (JNI)](#javaネイティブインターフェース-jni)
- [メモリ管理](#メモリ管理)
  - [JVMのメモリ構造](#jvmのメモリ構造)
  - [ヒープ領域(heap)](#ヒープ領域heap)
    - [ライフサイクル](#ライフサイクル-1)
    - [メソッドエリア](#メソッドエリア)
      - [ライフサイクル](#ライフサイクル-2)
    - [スタック領域（スレッドスタック）](#スタック領域スレッドスタック)
      - [構造](#構造)
      - [ライフサイクル](#ライフサイクル-3)
    - [ネイティブメソッドスタック（Cスタック）](#ネイティブメソッドスタックcスタック)
    - [ライフサイクル](#ライフサイクル-4)
    - [PCレジスタ](#pcレジスタ)
  - [ガーベージコレクタ（GC）](#ガーベージコレクタgc)
    - [GCの悩ましい点](#gcの悩ましい点)
      - [解決策](#解決策)
        - [世代別ガーベージコレクションの仕組み](#世代別ガーベージコレクションの仕組み)
- [プロセス](#プロセス)
  - [プロセス間の通信](#プロセス間の通信)
- [スレッド](#スレッド)
  - [プロセスとスレッド](#プロセスとスレッド)
  - [マルチタスク](#マルチタスク)
    - [プロセスベースのマルチタスク (マルチプロセッシング)](#プロセスベースのマルチタスク-マルチプロセッシング)
    - [スレッドベースのマルチタスク](#スレッドベースのマルチタスク)
  - [Javaにおけるスレッド](#javaにおけるスレッド)
  - [スレッドプール](#スレッドプール)
- [標準API](#標準api)
- [コレクション（Collection）](#コレクションcollection)
  - [各クラスの意味](#各クラスの意味)
  - [主なクラス](#主なクラス)
  - [ArrayListの仕様](#arraylistの仕様)
  - [Setの仕様](#setの仕様)
- [シリアライズ](#シリアライズ)
- [文字列操作のクラス](#文字列操作のクラス)
  - [String](#string)
  - [StringBuffer](#stringbuffer)
  - [StringBuilder](#stringbuilder)
  - [Pythonでは](#pythonでは)
- [型](#型)
  - [プリミティブ型](#プリミティブ型)
    - [ボックス化（プリミティブ型をオブジェクトとして扱う）](#ボックス化プリミティブ型をオブジェクトとして扱う)
  - [ジェネリック型](#ジェネリック型)
    - [使用方法](#使用方法)
- [エラー・例外](#エラー例外)
  - [Javaにおける例外クラス](#javaにおける例外クラス)
  - [例外の発生手順](#例外の発生手順)


## JVM (Java Virtual Machine)

### 役割
- Java プログラムを任意のデバイスまたはオペレーティングシステム上で実行できるようにする
- プログラムメモリを管理および最適化すること
- Javaバイトコードを実行できる実行環境を提供する

### ライフサイクル
- Javaクラスを実行するためにコマンドプロンプトで「java」コマンドを入力すると、JVMのインスタンスが生成されます。
このインスタンスが実行中のJavaプログラムを管理し、実行します。

### 部品
- メモリ領域
- クラスファイル形式
- レジスタセット
- ガベージコレクションされたヒープ
- 致命的なエラーの報告など
-

### 対応言語
- Scala
- Groovy
- Kotlin
多くの言語に対応するが、上記が人気。
JVMを使用する言語は、常にJavaライブラリにアクセスできる。

### よくある操作・機能
- JVMのメモリパフォーマンスの調整
- ファイルシステムアクセス
- ネットワークI/O のリソースを管理

### クラスローダー
#### 機能、動作
1. 読み込み
   1. .class形式のクラスファイルを、メモリに読み込む。
     1. .classファイルを読み込んで、対応するバイナリデータを生成し、ヒープメモリのメソッド領域に Class 型のオブジェクトを作成し保存します。
       1. Class型はjava.langで定義されている。
       2. プログラマは、これらの Class オブジェクトを使用して、クラス名、親名、メソッド、変数情報などのクラス レベルの情報を取得できます。
     2. 各「.class」ファイルについて、JVM はメソッド領域に次の情報を保存します。
       1. ロードされたクラスとその直接の親クラスの完全修飾名。
       2. 「.class」ファイルがクラス、インターフェイス、または列挙型に関連しているかどうか。
       3. 修飾子、変数、メソッド情報など
2. リンキング
   1. 検証、準備、および (オプションで) 解決を実行します。
      1. 検証:
         1. .classファイルの正確性を保証します。つまり、このファイルが適切にフォーマットされ、有効なコンパイラによって生成されたかどうかをチェックします。
         2. 検証が失敗すると、実行時例外java.lang.VerifyErrorが発生します。このアクティビティは、ByteCodeVerifier コンポーネントによって実行されます。
         3. このアクティビティが完了すると、クラスファイルをコンパイルする準備が整います。
      2. 準備:
         1. JVMはクラスの静的変数にメモリを割り当て、メモリをデフォルト値に初期化します。
      3. 解決策:
         1. これは、型のシンボリック参照を直接参照に置き換えるプロセスです。これは、メソッド領域を検索して参照されるエンティティを見つけることによって行われます。
3. 初期化
   1. このフェーズでは、すべての静的変数に、コードおよび静的ブロック (存在する場合) で定義された値が割り当てられます。これは、クラス内では上から下に、クラス階層では親から子に実行されます。
4. クラスローダーがクラスファイルを検索するときに起点となるパスは、モジュールシステムが導入されている場合はモジュールパス、そうでない場合はクラスパスになります。

#### クラスローダーの種類
下記の優先順位となる。
1. Bootstrap Classloader
2. Extension Classloader
3. System Classloader (Application Classloader)

1.Bootstrap Classloader
- java.lang.Stringクラスなど、Java SEのクラスライブラリによって提供される主要なクラスをロードする

2.Extension Classloader
- Java SEクラスライブラリをロードするクラスローダー
- 例えばjava.net.http.HttpClientクラスなどをロード

3.System Classloader (Application Classloader)
- 開発者が作成したクラスをロードするためのクラスローダー
-

### 実行エンジン
1. 仮想プロセッサ
2. インタプリタ
3. Just-In-Time コンパイラ

1.仮想プロセッサ

2.インタプリタ
- .classのバイトコードを一行ずつ解釈して実行します。
  - バイトコードストリームを読み取り、命令を実行します。
- ここでの欠点は、1 つのメソッドが複数回呼び出される場合、毎回解釈が必要になることです。

3.Just-In-Time コンパイラ
- インタプリタの効率を高めるために使用されます。
- バイトコード全体をコンパイルしてネイティブコードに変更するため、インタプリタがメソッド呼び出しの繰り返しを確認するたびに、JIT がその部分に直接ネイティブ コードを提供するので、再解釈が不要になり、効率が向上します。


### Javaネイティブインターフェース (JNI)
- ネイティブメソッドライブラリと連携し、実行に必要なネイティブライブラリ(C、C++)を提供するインターフェースです。
- これにより、JVM は C/C++ ライブラリを呼び出したり、ハードウェアに固有の C/C++ ライブラリによって呼び出されたりできるようになります。

1.ネイティブメソッドライブラリ
- 実行エンジンに必要なネイティブ ライブラリ(C、C++)のコレクションです。


## メモリ管理
### JVMのメモリ構造
JVMによって確保されたメモリ領域は、さらに複数の領域に分割される。
画像: https://media.geeksforgeeks.org/wp-content/uploads/Memory.png

JVMはOSが保有するメモリの一部を借りる。

借りたメモリ空間は、以下のように分けて使う。
1. Javaヒープ
   1. Javaのプログラム内で使用されるオブジェクトや配列が格納されるメモリ空間です。
   2. 一般的に「ヒープ」と言う場合はJavaヒープを示す。
2. Cヒープ
   1. JVMがネイティブライブラリを実行する際に使用するメモリ空間です。
3. スレッドスタック
   1. JVMが持つスレッドの情報を格納します。

画像: https://media.geeksforgeeks.org/wp-content/uploads/Memory.png

上記を家に例えると、Javaヒープが建物で、それ以外は庭である。

地面：OS
建物：JVMの種類や選択したGCの種類で間取りが変わるJavaヒープ
庭：Cヒープやスレッドスタックなど、Javaヒープ以外で使われるメモリ空間
住人：アプリケーションやGCを実行するスレッド


### ヒープ領域(heap)
1. プログラムで利用するデータ領域の一種。
2. 共有ランタイムデータ領域
3. 実際のオブジェクトをメモリに保存する
4. プログラムの実行につれて動的に確保される。
5. プログラムで利用する動的なデータ領域を確保するために利用される。
6. ヒープがいっぱいになると、GCが動き出す。
   1. Eden領域がいっぱいになると、GCが起動。

#### ライフサイクル
1. JVMの起動時にインスタンス化される。
2. JVMの終了時にヒープ領域は解放される。

#### メソッドエリア
1. ヒープ領域の論理部分

##### ライフサイクル
1. 仮想マシンの起動時に作成される

#### スタック領域（スレッドスタック）
1. データと部分的な結果を保存するために使用されます。
   1. メソッドの値を返したり動的リンクを実行したりする際に必要となるデータと部分的な結果を保存するために使用されます。
2. スタック用のメモリは連続している必要はありません。

##### 構造
1.Stack Frame
  1. Stack frameはスレッドのデータを含むデータ構造です。
  2. メソッドが呼び出されると、新しいフレームが作成されます。メソッドの呼び出しが完了すると、フレームが破棄されます。
  3. 各フレームには、独自のローカル変数配列 (LVA)、オペランド スタック (OS)、およびフレーム データ (FD) が含まれています。
  4. 特定の制御スレッド内の任意の時点でアクティブになるフレームは 1 つだけ (メソッドを実行するフレーム) です。
  5. フレームは、そのメソッドが別のメソッドを呼び出す場合、またはメソッドが完了した場合に、現在のメソッドを停止します。


##### ライフサイクル
1. スタックはスレッドの作成と同時に作成される
2.

#### ネイティブメソッドスタック（Cスタック）
1. Cスタックとも呼ばれる
2. JVMがネイティブライブラリを実行する際に使用するメモリ空間です。
3.

#### ライフサイクル
1. スレッドの作成時に各スレッドに割り当てられる

#### PCレジスタ
1. JVM スレッドに、それぞれ関連づけられる。
2. PC レジスタは、リターン アドレスまたは特定のプラットフォーム上のネイティブ ポインタを格納できます。


### ガーベージコレクタ（GC）

#### GCの悩ましい点
GCが動作する時、アプリケーションが一時停止する点。
GCが動作する時、すべてのオブジェクトを管理するため、他のすべてのスレッドとプロセスを一時停止する。

参考: https://gihyo.jp/dev/serial/01/jvm-arc/0004

##### 解決策
1. GCのチューニング
2. 世代別ガベージ コレクターの利用
   1. メモリが割り当てられたオブジェクトに age フィールドを追加して管理する。
   2. オブジェクトが何クロック サイクル生き残ったかに基づいて、オブジェクトがグループ化され、それに応じて「年齢」が割り当てられます。
   3. このようにして、ガベージ コレクション作業が分散されます。
   4. OOP言語との相性が良く、JVMやRubyはこれを利用している。

###### 世代別ガーベージコレクションの仕組み
以下の傾向を考慮して、オブジェクトは世代に分けて管理される。
1. 計算途上で利用される一時オブジェクトは数が多く、かつすぐさま破棄される率が高い
2. ある程度長く生存したオブジェクトは、以降も長く生存する率が高い

参考: https://ja.wikipedia.org/wiki/%E4%B8%96%E4%BB%A3%E5%88%A5%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3


## プロセス
プロセス（Process） は、コンピュータで動くアプリケーションやソフトウェアの一つ一つです。
例えば、ゲームやウェブブラウザがプロセスの一例です。
プロセスは、個別に箱（メモリという箱）に入って動いていて、他の箱とは独立しています。これによって、あるプロセスが問題を起こしても、他のプロセスには影響がありません。
プロセス同士が話すときは、特別な方法で情報をやり取りします。

### プロセス間の通信
1. ソケット、ソケット通信（Socket）
2. パイプ（Pipe）
共有メモリ（Shared Memory）
メッセージキュー（Message Queue）

ソケット、ソケット通信（Socket）:
ソケットは、ネットワーク通信に使用される方法で、異なるプロセスやコンピュータ間でデータを送受信できます。ソケットを使用して、プロセス間通信をローカルホスト内またはネットワーク上で行うことができます。

パイプ（Pipe）:
パイプは、プロセス間でデータを送受信するための一つの方法です。一方のプロセスがデータを書き込み、もう一方がそれを読み取ることができます。通常、親プロセスと子プロセスの間で使用され、リダイレクションなどのコマンドで使われることがあります。

共有メモリ（Shared Memory）:
共有メモリは、異なるプロセスが同じ物理メモリ領域にアクセスするための手法です。これにより、高速なデータ共有が可能ですが、適切な同期手法が必要です。

メッセージキュー（Message Queue）:
メッセージキューは、プロセス間で非同期メッセージをやり取りする方法です。一方のプロセスがメッセージを送信し、他方がそれを受信します。メッセージキューは、プロセス間通信の信頼性を確保します。


## スレッド
- 個別の実行パスを持つ
-

### プロセスとスレッド
プロセスとは個別の箱（メモリ）で動くアプリケーションやソフトウェアです。
そのプロセスの中で、共同作業をする小さな作業単位がスレッドです。

プロセス同士は独立していて、スレッドは同じプロセス内で情報を共有しながら協力して作業します。

### マルチタスク
#### プロセスベースのマルチタスク (マルチプロセッシング)
- プロセス間の通信コストが高い
- 読み込みに時間がかかる

#### スレッドベースのマルチタスク
- スレッドは軽量
- 同じアドレス空間を共有するため、スレッド間の通信コストも低い
  - 同じプロセス内のスレッドはメモリを共有する
-

### Javaにおけるスレッド
- main()がコードのエントリポイントとなるように、スレッドにもメインスレッドが存在する

### スレッドプール


## 標準API
よく使われる標準APIを以下にまとめる。

java.awt
    Graphics	すべてのグラフィックコンテキストの抽象基底クラス
java.awt.image
    BufferedImage	イメージデータを保持
java.io
    → このパッケージは、データ・ストリーム、直列化、ファイル・システムによるシステム入出力用に提供されています。
    BufferedInputStream
    BufferedReader	文字型入力ストリームから効率よくテキストを読み取る手段を提供
    BufferedWriter	文字型出力ストリームに効率よくテキストを書き込む手段を提供
    File	ファイルシステム情報を保持
    FileReader	テキストファイルからの読み取り手段を提供
java.lang
    ラッパクラス	基本データ型の操作に利用（Integer、Longなど）
    Math	指数関数、対数関数、三角関数などの基本的な演算処理
    Package	パッケージ名、仕様、バージョンに関する情報を保持
    String	文字列の加工・制御手段を提供する
    StringBuffer	可変長文字列の操作手段を提供する
    System	システム全般の制御、情報の取得手段を提供
java.sql
    CallableStatement	ストアドプロシージャを実行
    Connection	データベースとの接続を管理
    DatabaseMetaData	データベースの構成情報を保持
    PreparedStatement	準備済みSQL命令を実行
    ResultSet	データベースから抽出した結果セットを操作
    ResultSetMetaData	結果セットの構成情報を保持
    Statement	静的なSQL命令を実行
    DriverManager	JDBCドライバを管理
java.text
    DecimalFormat	10進数を整形する手段を提供
    SimpleDateFormat	日付型データを整形する手段を提供
java.util
    Calendar	標準的なカレンダーを提供
    Date	日付情報を保持、また操作する手段を提供
    ArrayList	サイズ変更可能な配列の実装
    HashMap	連想配列を実装
    Locale	ロケール（地域）情報を管理
    Scanner	入力ストリームをプリミティブ型またはString型に変換するテキストスキャナを提供
    ResourceBundle	リソース（プロパティ）ファイルの参照手段を提供
    StringTokenizer	文字列をトークンに分解
java.util.regex
    → 正規表現操作
    Matcher	正規表現マッチングを制御する
    Pattern	コンパイル済みの正規表現パターンを保持する
java.util.zip
    → zip操作
    ZipEntry	Zipエントリを表現
    ZipOutputStream	Zip形式で書き込みを行うための出力ストリーム

引用：https://kanda-it-school-kensyu.com/java-basic-intro-contents/jbi_ch10/jbi_1005/

## コレクション（Collection）
List, Set, Map

### 各クラスの意味
コレクション系のクラスに使われている Hash, Linked, Tree という接頭辞は、それぞれ特定の機能を表しています。
Hashは(ハッシュアルゴリズムによる) 検索機能、 Linkedは (リストアルゴリズムによる) 入力順序の保存機能、 Treeはソート機能 (並べ替え機能)です。

### 主なクラス
主なクラスは以下である。
1. List
   1. ArrayList ...サイズが自動的に拡張する配列。 配列のように、 同じ要素を重複して格納でき、 格納した順序で取り出せる ( 並び順が保存される)。
   2. LinkedList ...上記に加えて、 要素の挿入や削除の効率がよい
2. Set
   1. HashSet ...同じ要素を重複して格納できない。 要素の並び順は不定。
   2. LinkedHashSet ...重複不可で、格納した順番で取り出せる。
   3. TreeSet ...重複不可で、ソートした状態で取り出せる。
3. Map
   1. HashMap ...キーと値をペアで格納し、 キーで検索できる。 要素の並び順不定。
   2. LinkedHashMap ...検索でき、かつ格納した順番で取り出せる。
   3. TreeMap ...検索でき、かつキーでソートした状態で取り出せる

### ArrayListの仕様
初期化時の要素数は10個である。

### Setの仕様
Setはハッシュコードで要素を管理する。
ハッシュコードはランダムかつ一意な値となるため、Collection内な順番が保証されない。

## シリアライズ
Java のシリアル化は、オブジェクトの状態をバイトストリームに書き込むメカニズムです。
JPA,Hibernateなどで使用される。

## 文字列操作のクラス
文字列操作には、以下のクラスがある。
1. java.lang.String
2. java.lang.StringBuffer
3. java.lang.StringBuilder

操作の仕組みが異なり、実行速度も異なる。

### String
- 文字列は可変でない。
  - つまり、値を更新するたびに新しい変数を作成している。
- メモリの節約となる。
  - 他のクラスに比べ変更への準備のためのメモリ確保は不要。ただし、文字列操作をする際はメモリを浪費する。

### StringBuffer
- 文字列は可変。配列のようになっている。
- マルチスレッドに対応している。スレッドセーフである。
- 速い。

### StringBuilder
- 文字列は可変。配列のようになっている。
- 単一のスレッドで動作する。
- 最も速い。

### Pythonでは
Stringがimmutableであるという原因から、同様に、Pythonではjoin()が使われる。

1. 配列に文字列を格納
2. join()で結合
という流れである。

## 型
### プリミティブ型
#### ボックス化（プリミティブ型をオブジェクトとして扱う）
プリミティブ型の値をオブジェクトとして扱うために、Javaではラッパークラスが用意されている。
Java5からオートボクシングという機能が追加され、この互換が自動的に行われるようになった。

boxing（ボックス化）とは、プリミティブ型をオブジェクト型に変換することを指す。
https://ja.wikipedia.org/wiki/%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E5%8C%96

### ジェネリック型
クラス、メソッドにおいて、型をパラメーター（引数）にすることができる。

#### 使用方法
- 参照型のみ使用できる。
- パラメーターの文字は以下
```
T型
E - 要素
K - キー
N - 番号
V - 値
```

- 上限付きジェネリック
```
<? extends Number>
```

- 下限付きジェネリック
```
<? super Integer>
```


## エラー・例外
### Javaにおける例外クラス
Throwableを継承する。
Exceptionクラスと、Errorクラスに大別される。
Exceptionクラスはプログラム内でキャッチされ、処理される例外を実装する。
Errorはランタイム環境(JRE)自体に関するエラーを示す。

### 例外の発生手順
1)
ランタイム システムはコール スタックを検索して、発生した例外を処理できるコード ブロックを含むメソッドを見つけます。 コードのブロックは例外ハンドラーと呼ばれます。

2)
ランタイム システムは、例外が発生したメソッドから検索を開始し、メソッドが呼び出された逆の順序でコール スタックを処理します。

3)
適切なハンドラーが見つかった場合は、発生した例外をそのハンドラーに渡します。 適切なハンドラーとは、スローされる例外オブジェクトのタイプが、処理できる例外オブジェクトのタイプと一致することを意味します。

4)
ランタイム システムがコール スタック上のすべてのメソッドを検索し、適切なハンドラーが見つからなかった場合、ランタイム システムは例外オブジェクトをランタイム システムの一部であるデフォルトの例外ハンドラーに引き渡します。 このハンドラは、次の形式で例外情報を出力し、プログラムを異常終了します。

